class Solution {
public:
    int checkRecord(int n) {
        const int MOD = 1e9 + 7;

        // dp[i][j][k] - количество строк длины i, где:
        // j - количество отсутствий (0 или 1),
        // k - количество подряд идущих опозданий (0, 1 или 2)
        vector<vector<vector<long long>>> dp(
            n + 1, vector<vector<long long>>(2, vector<long long>(3, 0)));

        // Инициализация базовых случаев
        dp[0][0][0] = 1; // Начальный случай: пустая строка

        // Заполнение динамического массива
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= 1;
                 ++j) { // j - количество отсутствий (0 или 1)
                for (int k = 0; k <= 2;
                     ++k) { // k - количество подряд идущих L (0, 1 или 2)
                    // Добавление "P" (не изменяет количество отсутствий и
                    // опозданий)
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;

                    // Добавление "L"
                    if (k <
                        2) { // Если мы можем добавить 'L' (не будет 3 подряд)
                        dp[i][j][k + 1] =
                            (dp[i][j][k + 1] + dp[i - 1][j][k]) % MOD;
                    }

                    // Добавление "A" (увеличивает количество отсутствий на 1,
                    // если их меньше 1)
                    if (j < 1) { // Если мы можем добавить 'A' (не больше 1
                                 // отсутствия)
                        dp[i][j + 1][0] =
                            (dp[i][j + 1][0] + dp[i - 1][j][k]) % MOD;
                    }
                }
            }
        }

        // Суммируем все допустимые строки длины n
        long long result = 0;
        for (int j = 0; j <= 1; ++j) {     // Количество отсутствий
            for (int k = 0; k <= 2; ++k) { // Количество подряд идущих L
                result = (result + dp[n][j][k]) % MOD;
            }
        }

        return result;
    }
};
